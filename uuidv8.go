// Package uuidv8country provides UUID v8 generation with embedded country codes.
//
// This package implements a custom UUID v8 format that embeds country information
// along with timestamp data, making it useful for distributed systems that need
// to track geographical origin of entities.
package uuidv8country

import (
	"crypto/rand"
	"encoding/binary"
	"fmt"
	"time"

	"github.com/biter777/countries"
	"github.com/google/uuid"
)

// CountryUUIDv8 generates a UUID version 8 with an embedded country code.
//
// The UUID structure is as follows:
//   - Bytes 0-7: Unix timestamp in nanoseconds (big-endian)
//   - Bytes 8-10: Country code (3 bytes, accounting for RFC 4122 variant bits)
//   - Bytes 11-15: Random data
//   - Byte 6: Version field (upper 4 bits set to 8)
//   - Byte 8: Variant field (upper 2 bits set to 10 for RFC 4122)
//
// The function uses cryptographically secure random number generator for
// random portions of the UUID.
//
// Example:
//
//	u, err := CountryUUIDv8(countries.Russia)
//	if err != nil {
//		log.Fatal(err)
//	}
//	fmt.Println(u) // Output: xxxxxxxx-xxxx-8xxx-xxxx-xxxxxxxxxxxx
//
// Returns an error if random number generation fails.
func CountryUUIDv8(country countries.CountryCode) (uuid.UUID, error) {
	var uuidBytes [16]byte

	if _, err := rand.Read(uuidBytes[:]); err != nil {
		return uuid.Nil, err
	}

	timestamp := uint64(time.Now().UnixNano())

	binary.BigEndian.PutUint64(uuidBytes[0:8], timestamp)

	// Embed country code (3 bytes is sufficient for all countries)
	// Use bytes 8-10 for country code
	countryCode := uint32(country)
	uuidBytes[8] = byte(countryCode >> 16)
	uuidBytes[9] = byte(countryCode >> 8)
	uuidBytes[10] = byte(countryCode)

	// Set version 8 (bits 48-51, upper 4 bits of byte 6)
	uuidBytes[6] = (uuidBytes[6] & 0x0f) | 0x80

	// Set RFC 4122 variant (bits 64-65, upper 2 bits of byte 8)
	uuidBytes[8] = (uuidBytes[8] & 0x3f) | 0x80

	u, err := uuid.FromBytes(uuidBytes[:])
	if err != nil {
		return uuid.Nil, err
	}

	return u, nil
}

// ExtractCountry extracts the country code from a UUID v8 generated by CountryUUIDv8.
//
// The function validates that the provided UUID is version 8 before attempting
// to extract the country code. It properly handles the RFC 4122 variant bits
// when reading the country code from bytes 8-10.
//
// Example:
//
//	u, _ := CountryUUIDv8(countries.Germany)
//	country, err := ExtractCountry(u)
//	if err != nil {
//		log.Fatal(err)
//	}
//	fmt.Println(country) // Output: Germany
//
// Returns an error if the UUID is not version 8.
func ExtractCountry(u uuid.UUID) (countries.CountryCode, error) {
	uuidBytes := u[:]

	// Validate version
	version := (uuidBytes[6] & 0xf0) >> 4
	if version != 8 {
		return countries.Unknown, fmt.Errorf("not a UUID v8: version %d", version)
	}

	// Extract country code from bytes 8-10
	// Account for variant bits in byte 8
	countryCode := uint32(uuidBytes[8]&0x3f)<<16 | uint32(uuidBytes[9])<<8 | uint32(uuidBytes[10])

	return countries.CountryCode(countryCode), nil
}

// GetTimestamp extracts the timestamp from a UUID generated by CountryUUIDv8.
//
// The timestamp is stored in the first 8 bytes of the UUID as a Unix timestamp
// in nanoseconds (big-endian format).
//
// Example:
//
//	u, _ := CountryUUIDv8(countries.Japan)
//	timestamp := GetTimestamp(u)
//	fmt.Println(timestamp.Format(time.RFC3339))
//
// This function does not validate the UUID version, so it can be called on any UUID,
// though it will only return meaningful results for UUIDs generated by CountryUUIDv8.
func GetTimestamp(u uuid.UUID) time.Time {
	uuidBytes := u[:]
	timestamp := binary.BigEndian.Uint64(uuidBytes[0:8])
	return time.Unix(0, int64(timestamp))
}
